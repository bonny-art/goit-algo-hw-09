# Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування

## Введення

При вирішенні задачі знаходження монет, які сумарно складають певну величину, використовуються два основні підходи: жадібний алгоритм та алгоритм динамічного програмування. Обидва методи мають свої переваги та недоліки, які виявляються в залежності від особливостей вхідних даних.

## Результати випробувань

### Тестові випадки:

- Номінали монет: `[25, 10, 1]`, Сума: `30`
- Номінали монет: `[50, 20, 10, 5]`, Сума: `113`
- Номінали монет: `[100, 50, 20]`, Сума: `87`
- Номінали монет: `[7, 6, 2]`, Сума: `10`
- Номінали монет: `[50, 25, 10, 5, 2, 1]`, Сума: `2573`

### Результати

| Сума | Номінали монет      | Жадібний алгоритм (Час, Сума, Монет, Монети)     | Динамічне програмування (Час, Сума, Монет, Монети) |
| ---- | ------------------- | ------------------------------------------------ | -------------------------------------------------- |
| 30   | 25, 10, 1           | 0.0092 мс, 30, 6, {25: 1, 1: 5}                  | 0.0172 мс, 30, 3, {10: 3}                          |
| 113  | 50, 20, 10, 5       | 0.0028 мс, 110, 3, {50: 2, 10: 1}                | 0.0626 мс, 110, 3, {50: 2, 10: 1}                  |
| 87   | 100, 50, 20         | 0.0025 мс, 70, 2, {50: 1, 20: 1}                 | 0.0212 мс, 80, 4, {20: 4}                          |
| 10   | 7, 6, 2             | 0.0026 мс, 9, 2, {7: 1, 2: 1}                    | 0.0110 мс, 10, 3, {6: 1, 2: 2}                     |
| 2573 | 50, 25, 10, 5, 2, 1 | 0.0035 мс, 2573, 55, {50: 51, 10: 2, 2: 1, 1: 1} | 1.0613 мс, 2573, 55, {50: 51, 10: 2, 2: 1, 1: 1}   |

### Середній час виконання:

- Жадібний алгоритм: **0.0041 мс**
- Динамічне програмування: **0.2347 мс**

## Аналіз

### Час виконання

1. **Жадібний алгоритм**:

   - Загалом, жадібний алгоритм показав швидші результати у всіх тестах, за винятком ситуацій, коли він не зміг досягти точної суми (як у випадку з сумою 10 та монетами `[7, 6, 2]`).
   - Недоліком жадібного алгоритму є менш оптимальний вибір монет, що виливається в більшу їх загальну кількість та/або неможливість набрати повністю необхідну суму, навіть якщо наявні номінали монет це дозволяють.
   - Час виконання жадібного алгоритму в середньому склав всього 0.0041 мс, що свідчить про його високу швидкість обробки.

2. **Динамічне програмування**:
   - Динамічне програмування є більш повільним методом, з середнім часом виконання 0.2347 мс.
   - Однак у випадках, коли жадібний алгоритм не може досягти точної суми, динамічне програмування демонструє свою перевагу, оскільки здатне знайти оптимальне рішення.
   - Також динамічне програмування виграє у деяких випадках, дозволяючи вирішити поставлену задачу меншою кількістю монет, ніж жадібний алгоритм.

### О(n) ефективність

- **Жадібний алгоритм**: О(n) у найкращому випадку, оскільки він просто проходить через монети, щоб скласти суму.
- **Динамічне програмування**: О(n\*m), де n — кількість монет, а m — сума, оскільки алгоритм розглядає всі можливі варіанти для досягнення заданої суми.

### Продуктивність при великих сумах

- Для великих сум (наприклад, 2573) жадібний алгоритм демонструє вражаючу продуктивність, обробляючи його за 0.0035 мс, в той час як динамічне програмування споживає значно більше часу (1.0613 мс).
- Це свідчить про те, що жадібний алгоритм більш ефективний для задач, що включають велику кількість монет, які підходять для досягнення великої суми.

## Висновок

Жадібний алгоритм є чудовим вибором для задач, де монети мають певну структуру, яка дозволяє швидко знаходити рішення. Динамічне програмування, хоч і є повільнішим, забезпечує більш точні результати, коли жадібний алгоритм не може досягти точної суми або вирішує задачу неоптимальною кількістю монет. Отже, вибір між цими алгоритмами має базуватися на специфіці задачі та структурі монет.
